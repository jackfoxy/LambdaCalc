tru = lambda t. lambda f. t;
fls = lambda t. lambda f. f;
and = lambda b. lambda c. b c fls;
or = lambda b. lambda c. b tru c;
not = lambda a. a fls tru;
nand = lambda a. lambda b. not (and a b);
nor = lambda a. lambda b. not (or a b);
xor = lambda a. lambda b. and (nand a b) (or a b);
xnor = lambda a. lambda b. not (xor a b);
impl = lambda a. lambda b. or (not a) b;
/*comment*/
cond = lambda p. lambda t. lambda f. p t f;
pair = lambda f. lambda s. lambda b. b f s;
fst = lambda p. p tru;
snd = lambda p. p fls;
c0 = lambda s. lambda z. z;
c1 = lambda s. lambda z. s z;
c2 = lambda s. lambda z. s (s z);
c3 = lambda s. lambda z. s (s (s z));
c4 = lambda s. lambda z. s (s (s (s z)));
c5 = lambda s. lambda z. s (s (s (s (s z))));
c6 = lambda s. lambda z. s (s (s (s (s (s z)))));
c7 = lambda s. lambda z. s (s (s (s (s (s (s z))))));
c8 = lambda s. lambda z. s (s (s (s (s (s (s (s z)))))));
c9 = lambda s. lambda z. s (s (s (s (s (s (s (s (s z))))))));
scc = lambda n. lambda s. lambda z. s (n s z);
plus = lambda m. lambda n. lambda s. lambda z. m s (n s z);
mult = lambda m. lambda n. m (plus n) c0;
exp = lambda m. lambda n. n (mult m) c1;
prd = lambda m. fst (m (lambda p. pair (snd p) (plus c1 (snd p))) (pair c0 c0));
iszro = lambda m. m (lambda x. fls) tru;
eql = lambda m. lambda n. and (iszro (m prd n)) (iszro (n prd m));

/*list my attempt*/
nil = lambda c. lambda n. n;
cons = lambda h. lambda t.lambda c. c (pair h t);
head = lambda l. l fst;
isnil = lambda l. not (xnor (l tru) tru); 
tail = lambda l. l snd;

l1 = cons c0 nil;
l2 = cons c1 l1;
h2 = head l2;
t1 = tail l2;
h1 = head t1;
t2 = tail t1;
isnil t1;
isnil t2;
x1 = head t2; /*exception*/
x2 = tail t2; /*exception*/


/*conditional tests*/
xnor tru (eql c1 (cond tru c1 c0));
xnor tru (eql c0 (cond fls c1 c0));
xnor fls (eql c1 (cond fls c1 c0));

/*exponate tests*/
xnor tru (eql c1 (exp c1 c0));
xnor tru (eql c1 (exp c1 c1));
xnor tru (eql c1 (exp c1 c2));
xnor tru (eql c1 (exp c2 c0));
xnor tru (eql c2 (exp c2 c1));
xnor tru (eql c4 (exp c2 c2));
xnor tru (eql c8 (exp c2 c3));
xnor tru (eql c9 (exp c3 c2));


/*TO DO: fold over list*/
id = lambda x. x;
/*fld = lambda f. lambda s. lambda l. cond (isnil l) (id s) ()*/

fix = lambda f. (lambda x. f (lambda y. x x y)) (lambda x. f (lambda y. x x y));

/*(λf.(λy.f(y y))(λy.f(y y)))(λf.λx. if x==0 then 1 else x*f(x-1)) */
/*fact = (lambda f. (lambda y. f (y y))(lambda y. f (y y)))(lambda f. lambda x. cond (iszro x) c1 (mult x (f (prd x))) c3 ) ;*/

